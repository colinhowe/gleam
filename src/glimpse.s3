Package uk.co.colinhowe.glimpse.compiler;

Helpers     
    letter = ['a' .. 'z'] | ['A' .. 'Z'];  
    digit = ['0' .. '9'];
    cr = 13;
    lf = 10;
    newline = cr | lf | cr lf;
    newline_character = [ cr + lf ];
    colon = ':';
    all = [ 0 .. 65535 ];
    quote = '"';
    
Tokens  
    whitespace = (' ' | '\t' | 13 10  | 10 | 13 )+;
    node = 'node';
    macro = 'macro';
    include = 'include';
    
    with = 'with';
    for = 'for';
    in = 'in';
    dynamic = 'dynamic';
    
    type_int = 'int';
    type_bool = 'bool';
    type_string = 'string';
    type_generator = 'generator';
    timport = 'import';
    
    //toplevel = 'top level';
    
    false = 'false';
    true = 'true';
    
    var = 'var';
    
    controller_token = 'controller';
    
    cascade = 'cascade';
    
    restrict = 'restrict';
    to = 'to';
    
    if = 'if';
    telse = 'else';
    
    controller_ref = 'c';
    
    property_ref = '@c.';
    
    dot = '.';
    bang = '!';
    
    identifier = 'top level' | letter (letter | digit | '_')*;
    number = digit+;
    
    lt = '<';
    gt = '>';
    
    string = '"' [[[all - '"'] - cr] - lf]* '"' | '""' (([all - '"']) | ('"' [all - '"']))* '""';

    colon = ':';
    
    lparen = '(';
    rparen = ')';
    lbrace = '{';
    rbrace = '}';
    lbracket = '[';
    rbracket = ']';
    
    comma = ',';
    
    equals = '=';
    
    increment = '++';
    
    rightarrow = '=>';
      
    
    single_line_comment = '//' [[all - cr] - lf]*;
    multi_line_comment = 
      '/*' ([all - '*'] 
      | (all '*' [all - '/']))* '*/';
    
    asterix = '*';
    
Ignored Tokens
    whitespace,
    single_line_comment,
    multi_line_comment;
    
Productions 
    view = import* controller? macro_defn* stmt* ;
    
    macro_defn =       
        {static} macro [name]:identifier [generic_defns]:generic_defns? [macro_args]:arg_defns? with [content_name]:identifier colon [content_type]:type [gen_args]:arg_defns? restriction ? generator 
        {-> New macro_defn(Null, name, [generic_defns.generic_defn], [macro_args.arg_defn], content_type, content_name, restriction, generator)}
      | {dynamic} dynamic macro [name]:identifier [generic_defns]:generic_defns? [macro_args]:arg_defns? with [content_name]:identifier colon [content_type]:type [gen_args]:arg_defns? restriction ? 
        {-> New macro_defn(dynamic, name, [generic_defns.generic_defn], [macro_args.arg_defn], content_type, content_name, restriction, Null)}
      ;
      
    name {-> identifier*} = 
        {simple} identifier {-> [identifier]}
      | {qualified} name dot identifier {-> [name.identifier, identifier]}
      ;
    
    controller = controller_token name {-> New controller([name.identifier])};
    
    stmt = {node} node_create
         | {macro} identifier opt_args? expr {-> New stmt.macro(identifier, [opt_args.argument], expr)}
         | {include} include_a 
         | {var_defn} var_defn
         | {increment} identifier increment {-> New stmt.increment(identifier)}
         | {assignment} identifier equals expr {-> New stmt.assignment(identifier, expr)}
         | {for} forloop
         | {if} ifelse 
         ;
         
    ifelse = if lparen expr rparen codeblock else? {-> New ifelse(expr, codeblock, else.codeblock) };
    
    else {-> codeblock} = telse codeblock {-> codeblock };
    
    codeblock = lbrace stmt+ rbrace {-> New codeblock([stmt]) } ;
    
    type = {string} type_string
         | {generator} type_generator
         | {int} type_int
         | {bool} type_bool
         | {qualified} name  {-> New type.qualified([name.identifier])}
         | {compound} type lt types gt {-> New type.compound(type, [types.type]) }
         ;
         
    import = timport import_type {-> New import(import_type) };
    
    import_type =
        {single} name {-> New import_type.single([name.identifier])}
      | {wildcard} name dot asterix {-> New import_type.wildcard([name.identifier])}
      ;
         
    types {-> type* } = 
            {singular} type {-> [type] }
          | {multiple} types comma type {-> [types.type, type] }
          ;
         
    expr = 
           {string} string
         | {generator} generator
         | {constant} number
         | {property} name {-> New expr.property([name.identifier])}
         | {controller_prop} controller_ref dot name {-> New expr.controller_prop([name.identifier])}
         | {false} false
         | {true} true
         | {invert} bang expr {-> New expr.invert(expr)}
         | {propertyref} property_ref name {-> New expr.propertyref([name.identifier])}
         ;
          
    var_defn = 
        var identifier var_defn_init {-> New var_defn(identifier, var_defn_init.expr)} ;
    
    var_defn_init {-> expr} = equals expr {-> expr};
    	
    restriction = restrict to identifiers {-> New restriction([identifiers.identifier])};
    
    identifiers {-> identifier*} = 
        {single} identifier {-> [identifier]}
      | {multiple} identifiers comma identifier {-> [identifiers.identifier, identifier]}
      ;
       
    generic_defns {-> generic_defn* } = lt generic_defns2 gt {-> [generic_defns2.generic_defn] };
    
    generic_defns2 {-> generic_defn* } =
        {single} generic_defn {-> [generic_defn] }
      | {multiple} generic_defns2 comma generic_defn {-> [generic_defns2.generic_defn, generic_defn] }
      ;
      
    generic_defn = identifier {-> New generic_defn(identifier) };
      
    include_a = include [the_include]:identifier opt_args? {-> New include_a(the_include, [opt_args.argument])};

    node_create {-> node_create} = 
        node identifier opt_args? expr {-> New node_create(identifier, [opt_args.argument], expr) }
      ;
      
    arg_defns {-> arg_defn* } = lparen arg_defns2 rparen {-> [arg_defns2.arg_defn] };
    
    arg_defns2 {-> arg_defn*} = 
        {single} arg_defn {-> [arg_defn]}
      | {multiple} arg_defns2 comma arg_defn {-> [arg_defns2.arg_defn, arg_defn]}
      ;

    arg_defn = modifier* [name]:identifier colon [type]:type var_defn_init? {-> New arg_defn([modifier], type, name, var_defn_init.expr) }; 
    
    modifier = cascade {-> New modifier.cascade()};
    
    generator = lbrace gen_args? stmt+ rbrace {-> New generator([gen_args.arg_defn], [stmt])};
    
    gen_args {-> arg_defn*} = arg_defns2 rightarrow {-> [arg_defns2.arg_defn] };
    
    opt_args {-> argument* } = lparen arguments rparen {-> [arguments.argument] };
    
    arguments {-> argument* } = 
        {single} argument {-> [argument]}
      | {multiple} argument comma arguments {-> [argument, arguments.argument] }
      ;
      
    argument = identifier colon expr {-> New argument(identifier, expr) };
    
    forloop = for lparen type identifier in expr rparen lbrace stmt+ rbrace {-> New forloop(type, identifier, expr, [stmt]) };
    
    //string_literal = string;
                     
Abstract Syntax Tree
    view = import* controller? macro_defn* stmt+;
    
    controller = identifier*;
    
    arg_defn = modifier* type identifier [default]:expr?;
    
    generic_defn = identifier;
    
    argument = identifier expr; 
    
    modifier =
        {cascade}
      ;
      
    restriction = identifier*;
    
    stmt = {node}  node_create
         | {macro} identifier [arguments]:argument* expr
         | {include} include_a
         | {var_defn} var_defn
         | {increment} identifier
         | {assignment} identifier expr
         | {for} forloop
         | {if} ifelse
         ;
         
    codeblock = stmt+ ;
         
    var_defn = 
      identifier expr?;
      
    expr = 
        {string} string
      | {generator} generator
      | {constant} number
      | {property} identifier*
      | {controller_prop} identifier*
      | {false} false
      | {true} true
      | {invert} expr
      | {propertyref} identifier*
      ;
      
    ifelse = expr codeblock [else]:codeblock? ;
    
    type = 
       {string} type_string
     | {generator} type_generator
     | {int} type_int
     | {bool} type_bool
     | {qualified} identifier*
     | {compound} [parenttype]:type [types]:type*
     ;     
     
    import = import_type;
    
    import_type =
        {single} identifier*
      | {wildcard} identifier*
      ;
      
    node_create = 
      [id]:identifier [arguments]:argument* [expr]:expr 
      ;
      
    generator = arg_defn* stmt+;
    
    forloop = type identifier expr stmt+;
    
    macro_defn = dynamic? [name]:identifier [generic_defn]:generic_defn* [arg_defn]:arg_defn* [content_type]:type [content_name]:identifier restriction? generator?;
    
    include_a = [the_include]:identifier  [arguments]:argument*;
    
