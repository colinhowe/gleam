Package uk.co.colinhowe.glimpse.compiler;

Helpers     
    letter = ['a' .. 'z'] | ['A' .. 'Z'];  
    digit = ['0' .. '9'];
    cr = 13;
    lf = 10;
    newline = cr | lf | cr lf;
    newline_character = [ cr + lf ];
    colon = ':';
    all = [ 0 .. 65535 ];
    quote = '"';
    
Tokens  
    whitespace = (' ' | '\t' | 13 10  | 10 | 13 )+;
    node = 'node';
    macro = 'macro';
    include = 'include';
    
    with = 'with';
    for = 'for';
    in = 'in';
    dynamic = 'dynamic';
    
    type_int = 'int';
    type_bool = 'bool';
    type_string = 'string';
    type_generator = 'generator';
    
    false = 'false';
    true = 'true';
    
    var = 'var';
    
    controller_token = 'controller';
    
    if = 'if';
    telse = 'else';
    
    controller_ref = 'c';
    
    property_ref = '@c.';
    
    dot = '.';
    bang = '!';
    
    identifier = letter (letter | digit | '_')*;
    number = digit+;
    
    lt = '<';
    gt = '>';
    
    string = '"' [[[all - '"'] - cr] - lf]* '"' | '""' all* '""';

    colon = ':';
    
    lparen = '(';
    rparen = ')';
    lbrace = '{';
    rbrace = '}';
    lbracket = '[';
    rbracket = ']';
    
    comma = ',';
    
    equals = '=';
    
    increment = '++';
    
    rightarrow = '=>';
    
    single_line_comment = '//' [[all - cr] - lf]*;
    multi_line_comment = '/*' (all)* '*/';
    
Ignored Tokens
    whitespace,
    single_line_comment,
    multi_line_comment;
    
Productions 
    view = controller? defn* stmt* ;
    
    defn = 
        {m} macro_defn 
      | {d} dynamic_macro_defn;
    
    name = 
        {simple} identifier
      | {qualified} identifier dot name {-> New name.qualified(identifier, name)}
      ;
    
    controller = controller_token name {-> New controller(name)};
    
    stmt = {node} node_create
         | {macro} macro_invoke
         | {include} include_a 
         | {var_defn} var_defn
         | {increment} identifier increment {-> New stmt.increment(identifier)}
         | {assignment} identifier equals expr {-> New stmt.assignment(identifier, expr)}
         | {for} forloop
         | {if} ifelse 
         ;
         
    ifelse = if lparen expr rparen codeblock else? {-> New ifelse(expr, codeblock, else) };
    
    else = telse codeblock {-> New else(codeblock) };
    
    codeblock = lbrace stmt+ rbrace {-> New codeblock([stmt]) } ;
    
    type = {string} type_string
         | {generator} type_generator
         | {int} type_int
         | {bool} type_bool
         | {qualified} qualified_type 
         | {compound} type lt types gt {-> New type.compound(type, [types.type]) }
         ;
         
    qualified_type =
        {simple} identifier
      | {compound} identifier dot qualified_type {-> New qualified_type.compound(identifier, qualified_type) };
         
         
    types {-> type* } = 
            {singular} type {-> [type] }
          | {multiple} types comma type {-> [types.type, type] }
          ;
         
    expr = 
           {string} string
         | {generator} generator
         | {constant} number
         | {property} name
         | {controller_prop} controller_ref dot name {-> New expr.controller_prop(name)}
         | {false} false
         | {true} true
         | {invert} bang expr {-> New expr.invert(expr)}
         | {propertyref} property_ref name {-> New expr.propertyref(name)}
         ;
          
    var_defn = 
        var identifier var_defn_init {-> New var_defn(identifier, var_defn_init.expr)} ;
    
    var_defn_init {-> expr} = equals expr {-> expr};
    	
    
    macro_defn = 
      macro [name]:identifier [generic_defns]:generic_defns? [macro_args]:arg_defns? with [content_name]:identifier colon [content_type]:type [gen_args]:arg_defns? generator 
      {-> New macro_defn(name, [generic_defns.generic_defn], [macro_args.arg_defn], content_type, content_name, generator)}
      ;
      
    dynamic_macro_defn = 
      dynamic macro [name]:identifier [generic_defns]:generic_defns? [macro_args]:arg_defns? with [content_name]:identifier colon [content_type]:type [gen_args]:arg_defns? 
      {-> New dynamic_macro_defn(name, [generic_defns.generic_defn], [macro_args.arg_defn], content_type, content_name)}
      ;
      
    generic_defns {-> generic_defn* } = lt generic_defns2 gt {-> [generic_defns2.generic_defn] };
    
    generic_defns2 {-> generic_defn* } =
        {single} generic_defn {-> [generic_defn] }
      | {multiple} generic_defns2 comma generic_defn {-> [generic_defns2.generic_defn, generic_defn] }
      ;
      
    generic_defn = identifier {-> New generic_defn(identifier) };
      
    macro_invoke = 
        {with_generator} identifier opt_args? generator {-> New macro_invoke.with_generator(identifier, [opt_args.argument], generator)}
      | {with_string} identifier opt_args? string {-> New macro_invoke.with_string(identifier, [opt_args.argument], string)}
      ;
    
    include_a = include [the_include]:identifier opt_args? {-> New include_a(the_include, [opt_args.argument])};

    node_create {-> node_create} = 
        node identifier opt_args? expr {-> New node_create(identifier, [opt_args.argument], expr) }
      ;
      
    arg_defns {-> arg_defn* } = lparen arg_defns2 rparen {-> [arg_defns2.arg_defn] };
    
    arg_defns2 {-> arg_defn*} = 
        {single} arg_defn {-> [arg_defn]}
      | {multiple} arg_defns2 comma arg_defn {-> [arg_defns2.arg_defn, arg_defn]}
      ;

    arg_defn = [name]:identifier colon [type]:type {-> New arg_defn(type, name) }; 
    
    generator = lbrace gen_args? stmt+ rbrace {-> New generator([gen_args.arg_defn], [stmt])};
    
    gen_args {-> arg_defn*} = arg_defns2 rightarrow {-> [arg_defns2.arg_defn] };
    
    opt_args {-> argument* } = lparen arguments rparen {-> [arguments.argument] };
    
    arguments {-> argument* } = 
        {single} argument {-> [argument]}
      | {multiple} argument comma arguments {-> [argument, arguments.argument] }
      ;
      
    argument = identifier colon expr {-> New argument(identifier, expr) };
    
    forloop = for lparen type identifier in expr rparen lbrace stmt+ rbrace {-> New forloop(type, identifier, expr, [stmt]) };
    
    //string_literal = string;
                     
Abstract Syntax Tree
    view = controller? defn* stmt+;
    
    defn =
        {m} macro_defn
      | {d} dynamic_macro_defn ;
    
    controller = name;
    
    name = 
      {simple} identifier |
      {qualified} identifier name
      ;
    
    arg_defn = type identifier;
    
    generic_defn = identifier;
    
    argument = identifier expr; 
    
    stmt = {node}  node_create
         | {macro} macro_invoke
         | {include} include_a
         | {var_defn} var_defn
         | {increment} identifier
         | {assignment} identifier expr
         | {for} forloop
         | {if} ifelse
         ;
         
    codeblock = stmt+ ;
         
    var_defn = 
      identifier expr?;
      
    expr = 
        {string} string
      | {generator} generator
      | {constant} number
      | {property} name
      | {controller_prop} name
      | {false} false
      | {true} true
      | {invert} expr
      | {propertyref} name
      ;
      
    ifelse = expr codeblock else? ;
    else = codeblock ;  
    
    type = 
       {string} type_string
     | {generator} type_generator
     | {int} type_int
     | {bool} type_bool
     | {qualified} qualified_type
     | {compound} [parenttype]:type [types]:type*
     ;     
     
    qualified_type = 
      {simple} identifier
    | {compound} identifier qualified_type;
      
    node_create = 
      [id]:identifier [arguments]:argument* [expr]:expr 
      ;
      
    generator = arg_defn* stmt+;
    
    forloop = type identifier expr stmt+;
    
    macro_defn = [name]:identifier [generic_defn]:generic_defn* [arg_defn]:arg_defn* [content_type]:type [content_name]:identifier generator;
    
    dynamic_macro_defn = [name]:identifier [generic_defn]:generic_defn* [arg_defn]:arg_defn* [content_type]:type [content_name]:identifier;

    macro_invoke = {with_generator} identifier [arguments]:argument* generator 
                 | {with_string} identifier [arguments]:argument* string;
    
    include_a = [the_include]:identifier  [arguments]:argument*;
    
