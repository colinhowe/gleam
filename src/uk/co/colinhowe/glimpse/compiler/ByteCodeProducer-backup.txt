/**
 * 
 */
package uk.co.colinhowe.glimpse.compiler;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.concurrent.atomic.AtomicInteger;

import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

import com.sun.tools.internal.xjc.generator.bean.MethodWriter;

import uk.co.colinhowe.glimpse.CompilationError;
import uk.co.colinhowe.glimpse.CompilationResult;
import uk.co.colinhowe.glimpse.Node;
import uk.co.colinhowe.glimpse.compiler.analysis.DepthFirstAdapter;
import uk.co.colinhowe.glimpse.compiler.node.AArgDefn;
import uk.co.colinhowe.glimpse.compiler.node.AArgument;
import uk.co.colinhowe.glimpse.compiler.node.AAssignmentStmt;
import uk.co.colinhowe.glimpse.compiler.node.AConstantExpr;
import uk.co.colinhowe.glimpse.compiler.node.AController;
import uk.co.colinhowe.glimpse.compiler.node.AControllerPropExpr;
import uk.co.colinhowe.glimpse.compiler.node.AGenerator;
import uk.co.colinhowe.glimpse.compiler.node.AGeneratorExpr;
import uk.co.colinhowe.glimpse.compiler.node.AGeneratorType;
import uk.co.colinhowe.glimpse.compiler.node.AIncludeA;
import uk.co.colinhowe.glimpse.compiler.node.AIncludeStmt;
import uk.co.colinhowe.glimpse.compiler.node.AIncrementStmt;
import uk.co.colinhowe.glimpse.compiler.node.AIntType;
import uk.co.colinhowe.glimpse.compiler.node.AMacroDefn;
import uk.co.colinhowe.glimpse.compiler.node.AMacroStmt;
import uk.co.colinhowe.glimpse.compiler.node.ANoInitVarDefn;
import uk.co.colinhowe.glimpse.compiler.node.ANodeCreate;
import uk.co.colinhowe.glimpse.compiler.node.APropertyExpr;
import uk.co.colinhowe.glimpse.compiler.node.AQualifiedName;
import uk.co.colinhowe.glimpse.compiler.node.ASimpleName;
import uk.co.colinhowe.glimpse.compiler.node.AStringExpr;
import uk.co.colinhowe.glimpse.compiler.node.AStringType;
import uk.co.colinhowe.glimpse.compiler.node.AView;
import uk.co.colinhowe.glimpse.compiler.node.AWithGeneratorMacroInvoke;
import uk.co.colinhowe.glimpse.compiler.node.AWithInitVarDefn;
import uk.co.colinhowe.glimpse.compiler.node.AWithStringMacroInvoke;
import uk.co.colinhowe.glimpse.compiler.node.PArgDefn;
import uk.co.colinhowe.glimpse.compiler.node.PArgument;
import uk.co.colinhowe.glimpse.compiler.node.PExpr;
import uk.co.colinhowe.glimpse.compiler.node.PMacroInvoke;
import uk.co.colinhowe.glimpse.compiler.node.PName;
import uk.co.colinhowe.glimpse.compiler.node.PType;
import uk.co.colinhowe.glimpse.compiler.node.TString;
import uk.co.colinhowe.glimpse.infrastructure.Scope;

public class ByteCodeProducer extends DepthFirstAdapter implements Opcodes {
  private final AtomicInteger generatorCount;
  private final List<String> methods;
  private final Stack<StringBuffer> buffers;
  private final Map<AGenerator, Integer> generatorIds;
  private final Set<String> currentMacroArguments;
  private final Set<String> macroDefns;
  private final StringBuffer controllerType;
  private final List<String> macroFilenames;
  private final Stack<ClassVisitor> classVisitors;
  private final Stack<MethodVisitor> methodVisitors;
  private final LineNumberProvider lineNumberProvider;
  private final Stack<String> owners;
  private final String viewname;
  private final Stack<Label> labels;
  private final Stack<String> generatorNames;
  
  private Stack<ClassWriter> classWriters;
  
  private int methodsBeforeMacroDefinition = 0;

  public ByteCodeProducer(String viewname, AtomicInteger generatorCount, List<String> methods,
      Stack<StringBuffer> buffers, Map<AGenerator, Integer> generatorIds,
      Set<String> currentMacroArguments, Set<String> macroDefns,
      StringBuffer controllerType, List<String> macroFilenames, ClassWriter classWriter, LineNumberProvider lineNumberProvider) {
    this.generatorCount = generatorCount;
    this.methods = methods;
    this.buffers = buffers;
    this.generatorIds = generatorIds;
    this.currentMacroArguments = currentMacroArguments;
    this.macroDefns = macroDefns;
    this.controllerType = controllerType;
    this.macroFilenames = macroFilenames;
    this.lineNumberProvider = lineNumberProvider;
    
    this.classVisitors = new Stack<ClassVisitor>();
    this.methodVisitors = new Stack<MethodVisitor>();
    this.owners = new Stack<String>();
    this.viewname = viewname;
    this.labels = new Stack<Label>();
    this.classWriters = new Stack<ClassWriter>();
    this.generatorNames = new Stack<String>();
    
    classWriters.push(classWriter);
  }
  
  @Override
  public void outAView(AView node) {
    // Return the list of nodes
    MethodVisitor mv = methodVisitors.peek();
    Label l0 = labels.peek();
    
    Label l2 = new Label();
    mv.visitLabel(l2);
    mv.visitVarInsn(ALOAD, 2);
    mv.visitInsn(ARETURN);
    
    Label l3 = new Label();
    mv.visitLabel(l3);
    mv.visitLocalVariable("this", "Lcheese/HelloWorld;", null, l0, l3, 0);
    
    // TODO This isn't technically accurate... the start label is too early
    mv.visitLocalVariable("scope", "Luk/co/colinhowe/glimpse/infrastructure/Scope;", null, l0, l3, 1);
    mv.visitLocalVariable("nodes", "Ljava/util/List;", "Ljava/util/List<Luk/co/colinhowe/glimpse/Node;>;", l0, l3, 2);
    mv.visitMaxs(0, 0);
    mv.visitEnd();
    
    classWriters.peek().visitEnd();
  }
  
  @Override
  public void outAPropertyExpr(APropertyExpr node) {
    MethodVisitor mv = methodVisitors.peek();
    
    // Get the value from the scope
    Label l1 = new Label();
    mv.visitLabel(l1);
    mv.visitVarInsn(ALOAD, 1);
    
    if (node.getName() instanceof ASimpleName) {
      ASimpleName simpleName = (ASimpleName)node.getName();
      mv.visitLdcInsn(simpleName.getIdentifier().getText());
    }
    
    mv.visitMethodInsn(INVOKEVIRTUAL, "uk/co/colinhowe/glimpse/infrastructure/Scope", "get", "(Ljava/lang/String;)Ljava/lang/Object;");
    // Leave the property on the stack for the next instruction to pick up
  }
  
  @Override
  public void inAView(AView node) {
    final ClassWriter classWriter = classWriters.peek();
    classWriter.visit(V1_6, ACC_PUBLIC + ACC_SUPER, viewname, null, "java/lang/Object", new String[] { "uk/co/colinhowe/glimpse/View" });

    // TODO Move this next to initialisation if possible
    FieldVisitor fv = classWriter.visitField(
        ACC_PRIVATE, "globalScope", Type.getDescriptor(Scope.class), null, null);
    fv.visitEnd();

    owners.push(viewname);
    
    // TODO Handle components

    // Constructor
    {
      MethodVisitor mv = classWriter.visitMethod(ACC_PUBLIC, "<init>", "()V", null, null);
      mv.visitCode();

      // Initialise super class
      Label l0 = new Label();
      mv.visitLabel(l0);
      mv.visitVarInsn(ALOAD, 0);
      mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V");
  
      // Initialise the scope
      Label l1 = new Label();
      mv.visitLabel(l1);
      mv.visitVarInsn(ALOAD, 0);
      mv.visitTypeInsn(NEW, Type.getInternalName(Scope.class));
      mv.visitInsn(DUP);
      mv.visitInsn(ACONST_NULL);
      mv.visitInsn(ICONST_0);
      mv.visitMethodInsn(INVOKESPECIAL, Type.getInternalName(Scope.class), "<init>", "(Luk/co/colinhowe/glimpse/infrastructure/Scope;Z)V"); 
      mv.visitFieldInsn(PUTFIELD, viewname, "globalScope", Type.getDescriptor(Scope.class));
      
      Label l2 = new Label();
      mv.visitLabel(l2);
      mv.visitInsn(RETURN);
  
      Label l3 = new Label();
      mv.visitLabel(l3);
      mv.visitLocalVariable("this", "L" + viewname + ";", null, l0, l3, 0);
      mv.visitMaxs(0, 0);
      mv.visitEnd();
    } 
    
    // Create the view method
    {
      // TODO Make this use the classes... currently mess!
      MethodVisitor mv = classWriter.visitMethod(
          ACC_PUBLIC, "view", "()Ljava/util/List;", "()Ljava/util/List<Luk/co/colinhowe/glimpse/Node;>;", null);
      mv.visitCode();
      
      Label l0 = new Label();
      labels.push(l0);
      mv.visitLabel(l0);
      mv.visitVarInsn(ALOAD, 0);
      mv.visitFieldInsn(GETFIELD, viewname, "globalScope", Type.getDescriptor(Scope.class));
      mv.visitVarInsn(ASTORE, 1);
      
      Label l1 = new Label();
      mv.visitLabel(l1);
      mv.visitTypeInsn(NEW, "java/util/LinkedList");
      mv.visitInsn(DUP);
      mv.visitMethodInsn(INVOKESPECIAL, "java/util/LinkedList", "<init>", "()V");
      mv.visitVarInsn(ASTORE, 2);
      
      // TODO Stuff goes here
      methodVisitors.push(mv);
    }
  }
  
  
  public String nameToString(PName node) {
    // Chunk the name down
    PName nameNode = node;
    String name = "";
    
    while (nameNode != null) {
      if (nameNode instanceof AQualifiedName) {
        name = "." + ((AQualifiedName)nameNode).getIdentifier().getText() + name;
        nameNode = ((AQualifiedName)nameNode).getName();
      } else {
        name = ((ASimpleName)nameNode).getIdentifier().getText() + name;
        nameNode = null;
      }
    }
    return name;
  }
  
  public String upperFirst(String other) {
    return other.substring(0, 1).toUpperCase() + other.substring(1);
  }
  
  public String nameToStringWithGets(PName node) {
    // Chunk the name down
    PName nameNode = node;
    String name = "";
    
    while (nameNode != null) {
      if (nameNode instanceof AQualifiedName) {
        name = ".get" + upperFirst(((AQualifiedName)nameNode).getIdentifier().getText()) + "()" + name;
        nameNode = ((AQualifiedName)nameNode).getName();
      } else {
        name = "get" + upperFirst(((ASimpleName)nameNode).getIdentifier().getText()) + "()" + name;
        nameNode = null;
      }
    }
    return name;
  }
  
  public String getStringFromExpr(PExpr expr) {
    if (expr instanceof AConstantExpr) {
      return ((AConstantExpr)expr).getNumber().getText();
    }
    
    return "0";
  }
  

  @Override
  public void caseTString(TString node) {
    
    if (node.getText().startsWith("<")) {
      String[] lines = node.getText().split("\n");
      
      // Determine indentation from the last line - and then 2 spaces more
      // TODO Make this configurable... or nicer
      int indentation = lines[lines.length - 1].indexOf(">") + 2;
      
      // Remove the indentation from each line and build up a string to output
      final StringBuffer outputStringBuffer = new StringBuffer();
      for (int i = 1; i < lines.length - 1; i++) {
        outputStringBuffer.append(lines[i].substring(indentation) + "\n");
      }
      // Remove the trailing + and quote and new line
      final String text = outputStringBuffer.substring(0, outputStringBuffer.length() - 1);
      node.setText(text);
    } else {
      node.setText(node.getText().replaceAll("\"", ""));
    }
  }

  @Override
  public void inAMacroDefn(AMacroDefn node) {

    // TODO Macros really should be ripped out into their own ASTs and processed separately
    methodsBeforeMacroDefinition = methods.size();
    
    // Create arguments 
    for (PArgDefn pargDefn : node.getArgDefn()) {
      if (pargDefn instanceof AArgDefn) {
        AArgDefn argDefn = (AArgDefn)pargDefn;
        currentMacroArguments.add(argDefn.getIdentifier().getText());
      }
    }
  }

  @Override
  public void outAController(AController node) {
    String name = nameToString(node.getName());
    controllerType.append(name);
  }

  @Override
  public void outAMacroDefn(AMacroDefn node) {
    // TODO Extract these out into new java files so that the class can be shared
    // Generate the macro code
    final StringBuffer buffer = new StringBuffer();
    buffer.append("public class macro" + node.getName().getText() + "{\n");
    
    String parameters = "Scope callerScope, Map<String, Object> _args, ";
    String environmentPuts = "";
    
    // TODO Finish parameters
    if (node.getContentType() instanceof AStringType) {
      parameters += "String " + node.getContentName().getText();
      environmentPuts = "    scope.add(\"" + node.getContentName().getText() + "\", " + node.getContentName().getText() + ");\n";
    } else if (node.getContentType() instanceof AGeneratorType) {
      parameters += "Generator " + node.getContentName().getText();
      environmentPuts = "    scope.add(\"" + node.getContentName().getText() + "\", " + node.getContentName().getText() + ");\n";
    }
    
    // TODO set the environment for the generator from the arguments
    
    // Simply call the generator with the parameters in scope
    buffer.append("  public List<Node> invoke(" + parameters + ") {\n");
    
    // TODO Default scope can be inserted before the new scope to provide fallback easily
    
    // Create a new scope for this macro to work in
    buffer.append("    Scope scope = new Scope(callerScope, true);\n");
    
    // Push all the arguments onto the environment
    buffer.append("    for (Entry<String, Object> entry : _args.entrySet()) {\n");
    buffer.append("      scope.add(entry.getKey(), entry.getValue());\n");
    buffer.append("    }\n");

    // Push the parameters onto the environment
    buffer.append(environmentPuts);
    
    int generatorId = generatorIds.get(node.getGenerator());
    
    buffer.append("    return new generator" + generatorId + "().view(scope);\n");
    buffer.append("  }\n");
    
    // Push all the generators etc into this macro definition
    while (methods.size() > methodsBeforeMacroDefinition) {
      String methodDefinition = methods.remove(methods.size() - 1);
      buffer.append(methodDefinition);
    }
    
    buffer.append("}\n");
//    macroDefns.add(buffer.toString());
    
    // Push this macro out to a file
    StringBuilder source = new StringBuilder();
    source.append("import java.util.List;\n");
    source.append("import java.util.LinkedList;\n");
    source.append("import java.util.Map;\n");
    source.append("import java.util.HashMap;\n");
    source.append("import uk.co.colinhowe.glimpse.Node;\n");
    source.append("import uk.co.colinhowe.glimpse.View;\n");
    source.append("import uk.co.colinhowe.glimpse.infrastructure.Scope;\n");
    source.append("import uk.co.colinhowe.glimpse.Generator;\n");
    source.append("import java.util.Map.Entry;\n");
    source.append(buffer.toString());
    
 // Output the class with line counters
    int j = 1;
    for (String line : source.toString().split("\n")) {
      System.out.println(String.format("%03d %s", j++, line));
    }
    
//    System.out.println(javaSource);
    
    // Output the source to a temporary file
    try {
      File file = new File("macro" + node.getName().getText() + ".java");
      file.deleteOnExit();
      
      BufferedWriter writer = new BufferedWriter(new FileWriter(file));
      writer.write(source.toString());
      writer.close();
      
      macroFilenames.add(file.getAbsolutePath());
      
      File clazz = new File("temp/macro" + node.getName().getText() + ".class");
      clazz.deleteOnExit();
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
    
    // Bin all the arguments
    currentMacroArguments.clear();
  }

  @Override
  public void outAIncludeStmt(AIncludeStmt node) {
    StringBuffer buffer = buffers.peek();
    
    // Build up arguments for the generator
    buffer.append("      {\n");
    buffer.append("        Scope genScope = new Scope(scope, false);\n");
    
    for (PArgument parg : ((AIncludeA)node.getIncludeA()).getArguments()) {
      AArgument arg = (AArgument)parg;
      String expr = getStringFromExpr(arg.getExpr());
      buffer.append("        genScope.add(\"" + arg.getIdentifier().getText() + "\", " + expr + ");\n");
    }
    
    String generatorName = ((AIncludeA)node.getIncludeA()).getTheInclude().getText();
    buffer.append("        nodes.addAll(((Generator)scope.get(\"" + generatorName + "\")).view(genScope));\n");
    buffer.append("      }\n");
  }

  @Override
  public void inAGenerator(AGenerator node) {
    final ClassWriter outerClassWriter = classWriters.peek();
    
    // Get the ID for the generator
    final int id = generatorCount.getAndIncrement();
    final String generatorName = "$generator" + id;

    generatorNames.push(generatorName);
    
    outerClassWriter.visitInnerClass(viewname + "$" + generatorName, viewname, generatorName, ACC_PRIVATE + ACC_STATIC);

    final ClassWriter innerClassWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);
    classWriters.push(innerClassWriter);

    innerClassWriter.visit(V1_6, ACC_SUPER, viewname + "$" + generatorName, null, "java/lang/Object", new String[] { "uk/co/colinhowe/glimpse/Generator" });
    innerClassWriter.visitInnerClass(viewname + "$" + generatorName, viewname, generatorName, ACC_PRIVATE + ACC_STATIC);

    generatorIds.put(node, id);

    owners.push(viewname);
    
    // Constructor
    {
      MethodVisitor mv = innerClassWriter.visitMethod(ACC_PRIVATE, "<init>", "()V", null, null);
      mv.visitCode();

      // Initialise super class
      Label l0 = new Label();
      mv.visitLabel(l0);
      mv.visitVarInsn(ALOAD, 0);
      mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V");
      mv.visitInsn(RETURN);
  
      Label l3 = new Label();
      mv.visitLabel(l3);
      mv.visitLocalVariable("this", "L" + viewname + "$" + generatorName + ";", null, l0, l3, 0);
      mv.visitMaxs(0, 0);
      mv.visitEnd();
    } 
    
    // Inner constructor
    {
      MethodVisitor mv = innerClassWriter.visitMethod(ACC_SYNTHETIC, "<init>", "(L" + viewname + "$" + generatorName + ";)V", null, null);
      mv.visitCode();
      Label l0 = new Label();
      mv.visitLabel(l0);
      mv.visitLineNumber(34, l0);
      mv.visitVarInsn(ALOAD, 0);
      mv.visitMethodInsn(INVOKESPECIAL, viewname + "$" + generatorName, "<init>", "()V");
      mv.visitInsn(RETURN);
      mv.visitMaxs(0, 0);
      mv.visitEnd();
    }
    
    // Create the view method
    {
      // TODO Make this use the classes... currently mess!
      MethodVisitor mv = innerClassWriter.visitMethod(
          ACC_PUBLIC, "view", "(Luk/co/colinhowe/glimpse/infrastructure/Scope;)Ljava/util/List;", "(Luk/co/colinhowe/glimpse/infrastructure/Scope;)Ljava/util/List<Luk/co/colinhowe/glimpse/Node;>;", null);
      mv.visitCode();
      
      Label l1 = new Label();
      mv.visitLabel(l1);
      mv.visitTypeInsn(NEW, "java/util/LinkedList");
      mv.visitInsn(DUP);
      mv.visitMethodInsn(INVOKESPECIAL, "java/util/LinkedList", "<init>", "()V");
      mv.visitVarInsn(ASTORE, 2);
      
      // TODO Stuff goes here
      methodVisitors.push(mv);
      labels.push(l1);
    }
  }

  @Override
  public void outAGenerator(AGenerator node) {
    // Return the list of nodes
    MethodVisitor mv = methodVisitors.pop();
    Label l0 = labels.pop();
    
    Label l2 = new Label();
    mv.visitLabel(l2);
    mv.visitVarInsn(ALOAD, 2);
    mv.visitInsn(ARETURN);
    
    Label l3 = new Label();
    mv.visitLabel(l3);
    
    String generatorName = generatorNames.pop();
    
    mv.visitLocalVariable("this", "L" + viewname + "$" + generatorName + ";", null, l0, l3, 0);
    
    // TODO This isn't technically accurate... the start label is too early
    mv.visitLocalVariable("scope", "Luk/co/colinhowe/glimpse/infrastructure/Scope;", null, l0, l3, 1);
    mv.visitLocalVariable("nodes", "Ljava/util/List;", "Ljava/util/List<Luk/co/colinhowe/glimpse/Node;>;", l0, l3, 2);
    mv.visitMaxs(0, 0);
    mv.visitEnd();
    
    ClassWriter cw = classWriters.pop();
    cw.visitEnd();
    
    // Write the bytes out
    byte[] bytes = cw.toByteArray();
    
    // Output the class to a class file!
    File file = new File("temp/" + viewname + "$" + generatorName + ".class");
//    file.deleteOnExit();
      
    try {
      FileOutputStream stream = new FileOutputStream(file);
      stream.write(bytes);
      stream.close();
      
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
    
  }

  @Override
  public void outAWithInitVarDefn(AWithInitVarDefn node) {
    MethodVisitor mv = methodVisitors.peek();

    final String varname = node.getIdentifier().getText();
    Label l1 = new Label();
    mv.visitLabel(l1);
    mv.visitVarInsn(ALOAD, 1);
    mv.visitLdcInsn(varname);

    PType type = node.getType();
    String typeString = "";
    if (type instanceof AIntType) {
//      mv.visitLocalVariable("x", "I", null, l1, l2, 2);
      int i = Integer.parseInt(getStringFromExpr(node.getExpr()));
      mv.visitIntInsn(SIPUSH, i);
      mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer;");
    } else if (type instanceof AStringType) {
      typeString = "String";
    } else if (type instanceof AGeneratorType) {
      throw new RuntimeException("Cannot declare a generator as a variable");
    }

    mv.visitMethodInsn(INVOKEVIRTUAL, "uk/co/colinhowe/glimpse/infrastructure/Scope", "add", "(Ljava/lang/String;Ljava/lang/Object;)V");
  }

  @Override
  public void outANoInitVarDefn(ANoInitVarDefn node) {

    PType type = node.getType();
    String typeString = "";
    String defaultValue = "";
    if (type instanceof AIntType) {
      typeString = "int";
      defaultValue = "0";
    } else if (type instanceof AStringType) {
      typeString = "String";
      defaultValue = "null";
    } else if (type instanceof AGeneratorType) {
      throw new RuntimeException("Cannot declare a generator as a variable");
    }
    buffers.peek().append("      " + typeString + " " + node.getIdentifier().getText() + "=" + defaultValue + ";\n");
    
    String varname = "";
    varname = node.getIdentifier().getText();
    buffers.peek().append("    environment.put(\"" + varname + "\", " + varname + ");\n");
  }

  @Override
  public void outAIncrementStmt(AIncrementStmt node) {
    String varName = node.getIdentifier().getText();
    buffers.peek().append("    {\n");
    buffers.peek().append("      int __a = (Integer)scope.get(\"" + varName + "\");\n");
    buffers.peek().append("      __a++;\n");
    buffers.peek().append("      scope.replace(\"" + varName + "\", __a);\n");
    buffers.peek().append("    }\n");
    super.outAIncrementStmt(node);
  }

  @Override
  public void outAAssignmentStmt(AAssignmentStmt node) {
    String varName = node.getIdentifier().getText();
    buffers.peek().append("    {\n");
    buffers.peek().append("      int __a = (Integer)scope.get(\"" + varName + "\");\n");
    buffers.peek().append("      __a = " + getStringFromExpr(node.getExpr()) + ";\n");
    buffers.peek().append("      scope.replace(\"" + varName + "\", __a);\n");
    buffers.peek().append("    }\n");
  }

  @Override
  public void outAMacroStmt(AMacroStmt node) {
    StringBuffer buffer = buffers.peek();
    PMacroInvoke invocation = node.getMacroInvoke();
    
    if (invocation instanceof AWithStringMacroInvoke) {
      AWithStringMacroInvoke stringInvocation = (AWithStringMacroInvoke)invocation;

      // Create the argument map
      buffer.append("    {\n");
      buffer.append("    Map<String, Object> args = new HashMap<String, Object>();\n");
      
      // Push the arguments on
      for (PArgument pargument : stringInvocation.getArguments()) {
        AArgument argument = (AArgument)pargument;
        String expr = null;
        if (argument.getExpr() instanceof AStringExpr) {
          expr = "\"" + ((AStringExpr)argument.getExpr()).getString().getText() + "\"";
        } else if (argument.getExpr() instanceof APropertyExpr) {
          APropertyExpr propertyExpr = (APropertyExpr)argument.getExpr();
          if (propertyExpr.getName() instanceof ASimpleName) {
            ASimpleName simpleName = (ASimpleName)propertyExpr.getName();
            expr = "scope.get(\"" + simpleName.getIdentifier().getText() + "\")";
          }
        }
        buffer.append("    args.put(\"" + argument.getIdentifier().getText() + "\", " + expr + ");\n");
      }
      
      // Call the macro
      String macroName = stringInvocation.getIdentifier().getText();
      String macroValue = stringInvocation.getString().getText();
      buffer.append("    nodes.addAll(new macro" + macroName + "().invoke(scope, args, \"" + macroValue + "\"));\n");
      buffer.append("    }\n");
    } else if (invocation instanceof AWithGeneratorMacroInvoke) {
      AWithGeneratorMacroInvoke generatorInvocation = (AWithGeneratorMacroInvoke)invocation;

      // Create the argument map
      buffer.append("    Map<String, Object> args = new HashMap<String, Object>();\n");
      
      // Push the arguments on
      for (PArgument pargument : generatorInvocation.getArguments()) {
        AArgument argument = (AArgument)pargument;
        String expr = null;
        if (argument.getExpr() instanceof AStringExpr) {
          expr = "\"" + ((AStringExpr)argument.getExpr()).getString().getText() + "\"";
        }
        buffer.append("    args.put(\"" + argument.getIdentifier().getText() + "\", " + expr + ");\n");
      }
      
      // Call the macro
      String macroName = generatorInvocation.getIdentifier().getText();
      int generatorId = generatorIds.get(generatorInvocation.getGenerator());
      buffer.append("    nodes.addAll(new macro" + macroName + "().invoke(scope, args, new generator" + generatorId + "()));\n");
    }
  }
  
  @Override
  public void inANodeCreate(ANodeCreate node) {
  }

  @Override
  public void outANodeCreate(ANodeCreate node) {
    String id = node.getId().getText();

    // TODO Expression evaluation should be done way better!
    if (node.getExpr() instanceof AGeneratorExpr) {
      
      // TODO Create the generator object :)
      AGeneratorExpr generatorExp = (AGeneratorExpr)node.getExpr();

      String generatorIdentifier = viewname + "$$generator" + generatorIds.get(generatorExp.getGenerator());
      MethodVisitor mv = methodVisitors.peek();
      mv.visitTypeInsn(NEW, generatorIdentifier);
      mv.visitInsn(DUP);
      mv.visitInsn(ACONST_NULL);
      mv.visitMethodInsn(INVOKESPECIAL, generatorIdentifier, "<init>", "(L" + generatorIdentifier + ";)V");

      mv.visitVarInsn(ALOAD, 2);
      mv.visitTypeInsn(NEW, "uk/co/colinhowe/glimpse/Node");
      mv.visitInsn(DUP);
      mv.visitTypeInsn(NEW, generatorIdentifier);
      mv.visitInsn(DUP);
      mv.visitInsn(ACONST_NULL);
      mv.visitMethodInsn(INVOKESPECIAL, generatorIdentifier, "<init>", "(L" + generatorIdentifier + ";)V");
      mv.visitVarInsn(ALOAD, 1);
      mv.visitMethodInsn(INVOKEVIRTUAL, generatorIdentifier, "view", "(Luk/co/colinhowe/glimpse/infrastructure/Scope;)Ljava/util/List;");
      mv.visitLdcInsn(id);
      mv.visitInsn(ACONST_NULL);
      mv.visitMethodInsn(INVOKESPECIAL, "uk/co/colinhowe/glimpse/Node", "<init>", "(Ljava/util/List;Ljava/lang/String;Ljava/lang/String;)V");
      
      // Set properties on the node
      addParameters(mv, node);
      
      mv.visitMethodInsn(INVOKEINTERFACE, "java/util/List", "add", "(Ljava/lang/Object;)Z");
      mv.visitInsn(POP);
    } else if (node.getExpr() instanceof AStringExpr){
      
      /*
       * Output bytecode equivalent to:
       *   Node n = new Node(null, "\"" + id + "\", \"" + text + "\"");
       *   nodes.add(n);
       */
      final AStringExpr stringExpr = (AStringExpr)node.getExpr();
      final String text = stringExpr.getString().getText();
      final MethodVisitor mv = methodVisitors.peek();

      final String nodeType = Type.getInternalName(Node.class);
      final String nodeCreationType = Type.getConstructorDescriptor(Node.class.getConstructors()[0]);
      
      // TODO Store the node off in a local variable, n
      // Then visitLocalVariable in this method.
      // This is fine as we can limit scope of the variable using labels and all is good
      
      Label l2 = new Label();
      mv.visitLabel(l2);
      mv.visitVarInsn(ALOAD, 2);
      mv.visitTypeInsn(NEW, "uk/co/colinhowe/glimpse/Node");
      mv.visitInsn(DUP);
      mv.visitInsn(ACONST_NULL);
      mv.visitLdcInsn(id);
      mv.visitLdcInsn(text);
      mv.visitMethodInsn(INVOKESPECIAL, "uk/co/colinhowe/glimpse/Node", "<init>", "(Ljava/util/List;Ljava/lang/String;Ljava/lang/String;)V");
      
      // Set properties on the node
      addParameters(mv, node);
      
      mv.visitMethodInsn(INVOKEINTERFACE, "java/util/List", "add", "(Ljava/lang/Object;)Z");
      mv.visitInsn(POP);
    } else if (node.getExpr() instanceof APropertyExpr) {
      APropertyExpr identifierExpr = (APropertyExpr)node.getExpr();
      
      if (identifierExpr.getName() instanceof ASimpleName) {
        String text = ((ASimpleName)identifierExpr.getName()).getIdentifier().getText();
        buffers.peek().append("    {\n");
        
        // TODO Fix this minging hack - work out scopings etc
        buffers.peek().append("      Object v = scope.get(\"" + text + "\");\n");
        
        buffers.peek().append("      Node n = new Node(null, \"" + id + "\", v.toString());\n");
        addParameters(buffers.peek(), node);
        buffers.peek().append("      nodes.add(n);\n");
        
        buffers.peek().append("    }\n");
      } else {
        throw new RuntimeException("Evaluating properties on a controller not supported, yet");
      }          
    } else if (node.getExpr() instanceof AControllerPropExpr) {
      String text = nameToStringWithGets(((AControllerPropExpr)node.getExpr()).getName());
      buffers.peek().append("    {\n");
      buffers.peek().append("      Node n = new Node(null, \"" + id + "\", controller." + text + ");\n");
      addParameters(buffers.peek(), node);
      buffers.peek().append("      nodes.add(n);\n");
      
      buffers.peek().append("    }\n");
    }
  }
  
  
  /**
   * Assume that the node is already on the stack and that the node must remain
   * on the stack afterwards.
   * 
   * @param mw
   * @param node
   */
  private void addParameters(final MethodVisitor mv, ANodeCreate node) {
    // Add the parameters on
    for (PArgument _argument : node.getArguments()) {
      AArgument argument = (AArgument)_argument;

      String name = argument.getIdentifier().getText();
      
      // Duplicate the node on the stack so that we can invoke a method on it
      mv.visitInsn(DUP);
      mv.visitLdcInsn(name);

      // Push the value on to the stack
      String value = null;
      if (argument.getExpr() instanceof AStringExpr) {
        value = ((AStringExpr)argument.getExpr()).getString().getText();
      } else if (node.getExpr() instanceof APropertyExpr) {
        APropertyExpr identifierExpr = (APropertyExpr)argument.getExpr();
        
        if (identifierExpr.getName() instanceof ASimpleName) {
          String text = ((ASimpleName)identifierExpr.getName()).getIdentifier().getText();
          value = "scope.get(\"" + text + "\").toString()";
        } else {
          throw new RuntimeException("Evaluating properties on a controller not supported, yet");
        }          
      } else {
        throw new RuntimeException("Expressions not supported yet");
      }
      
      mv.visitLdcInsn(value);
      mv.visitMethodInsn(INVOKEVIRTUAL, "uk/co/colinhowe/glimpse/Node", "setAttribute", "(Ljava/lang/String;Ljava/lang/String;)V");
    }
  }
  
  
  private void addParameters(final StringBuffer buffer, ANodeCreate node) {
    // Add the parameters on
    for (PArgument _argument : node.getArguments()) {
      AArgument argument = (AArgument)_argument;

      String name = argument.getIdentifier().getText();
      String value = null;
      if (argument.getExpr() instanceof AStringExpr) {
        value = "\"" + ((AStringExpr)argument.getExpr()).getString().getText() + "\"";
      } else if (node.getExpr() instanceof APropertyExpr) {
        APropertyExpr identifierExpr = (APropertyExpr)argument.getExpr();
        
        if (identifierExpr.getName() instanceof ASimpleName) {
          String text = ((ASimpleName)identifierExpr.getName()).getIdentifier().getText();
          value = "scope.get(\"" + text + "\").toString()";
        } else {
          throw new RuntimeException("Evaluating properties on a controller not supported, yet");
        }          
      } else {
        throw new RuntimeException("Expressions not supported yet");
      }
      
      buffer.append("    n.setAttribute(\"" + name + "\", " + value + ");\n");
    }
  }
}